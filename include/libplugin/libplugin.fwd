#pragma once

#include <type_traits>

namespace stdx {

// https://en.cppreference.com/w/cpp/experimental/is_detected

// these will no longer be useful with C++20 thanks to concepts (!)

template <typename default_t, typename always_void_t, template <typename...> typename op_t, typename... args_t>
struct detector {
    using value_t = std::false_type;
    using type = default_t;
};

template <typename default_t, template <typename...> typename op_t, typename... args_t>
struct detector<default_t, std::void_t<op_t<args_t...>>, op_t, args_t...> {
    using value_t = std::true_type;
    using type = op_t<args_t...>;
};

struct nonesuch {
    nonesuch() = delete;
    ~nonesuch() = delete;
    nonesuch(nonesuch const&) = delete;
    void operator=(nonesuch const&) = delete;
};

template <template <typename...> typename op_t, typename... args_t>
using is_detected = typename detector<nonesuch, void, op_t, args_t...>::value_t;

template <template <typename...> typename op_t, typename... args_t>
using detected_t = typename detector<nonesuch, void, op_t, args_t...>::type;

template <typename default_t, template <typename...> typename op_t, typename... args_t>
using detected_or = detector<default_t, void, op_t, args_t...>;

template <template <typename...> typename op_t, typename... args_t>
constexpr inline bool is_detected_v = is_detected<op_t, args_t...>::value;

template <typename default_t, template <typename...> typename op_t, typename... args_t>
using detected_or_t = typename detected_or<default_t, op_t, args_t...>::type;

template <typename expected_t, template <typename...> typename op_t, typename... args_t>
using is_detected_exact = std::is_same<expected_t, detected_t<op_t, args_t...>>;

template <typename expected_t, template <typename...> typename op_t, typename... args_t>
constexpr inline bool is_detected_exact_v = is_detected_exact<expected_t, op_t, args_t...>::value;

template <typename to_t, template <typename...> typename op_t, typename... args_t>
using is_detected_convertible = std::is_convertible<detected_t<op_t, args_t...>, to_t>;

template <typename to_t, template <typename...> typename op_t, typename... args_t>
constexpr inline bool is_detected_convertible_v = is_detected_convertible<to_t, op_t, args_t...>::value;
}

#include <libplugin/pluginfo.h>

#define LIBPLUGIN_VERIFY_PLUGIN(processor_class_m, controller_class_m)         \
    static_assert(libplugin::detail::is_processor_valid<processor_class_m>()); \
    static_assert(libplugin::detail::is_controller_valid<controller_class_m>());

#include <public.sdk/source/main/pluginfactory.h>

#define LIBPLUGIN_ADD_PLUGIN(processor_class_m, controller_class_m) \
    BEGIN_FACTORY_DEF(                                              \
        PLUGIN_COMPANY,                                             \
        PLUGIN_WEBSITE,                                             \
        "mailto:" PLUGIN_EMAIL)                                     \
    DEF_CLASS2(                                                     \
        INLINE_UID_FROM_FUID(PLUGIN_PROCESSOR_UID),                 \
        PClassInfo::kManyInstances,                                 \
        kVstAudioEffectClass,                                       \
        PLUGIN_NAME,                                                \
        Vst::kDistributable,                                        \
        PLUGIN_TYPE,                                                \
        PLUGIN_VERSION,                                             \
        kVstVersionString,                                          \
        processor_class_m::createInstance)                          \
    DEF_CLASS2(                                                     \
        INLINE_UID_FROM_FUID(PLUGIN_CONTROLLER_UID),                \
        PClassInfo::kManyInstances,                                 \
        kVstComponentControllerClass,                               \
        PLUGIN_NAME "Controller",                                   \
        0,                                                          \
        "",                                                         \
        PLUGIN_VERSION,                                             \
        kVstVersionString,                                          \
        controller_class_m::createInstance)                         \
    END_FACTORY

#if defined(LIBPLUGIN_BUILD_AAX_WRAPPER)
#include <pluginterfaces/base/futils.h>
#include <public.sdk/source/vst/aaxwrapper/aaxwrapper_description.h>
#define LIBPLUGIN_ADD_PLUGIN_AAX_WRAPPER()                                    \
    AAX_Effect_Desc effDesc = {                                               \
        PLUGIN_COMPANY,                                                       \
        PLUGIN_NAME,                                                          \
        CCONST(PLUGIN_COMPANY[0], PLUGIN_COMPANY[1], PLUGIN_COMPANY[2], 'A'), \
        CCONST(PLUGIN_NAME[0], PLUGIN_NAME[1], PLUGIN_NAME[2], 'B'),          \
        PLUGIN_TYPE,                                                          \
        { 0 },                                                                \
        PLUGIN_VERSION_MAJOR_INT,                                             \
        nullptr,                                                              \
        effPlugins,                                                           \
    };                                                                        \
    int* forceLinkAAXWrapper = &AAXWrapper_linkAnchor;                        \
    AAX_Effect_Desc* AAXWrapper_GetDescription()                              \
    {                                                                         \
        memcpy(                                                               \
            effDesc.mVST3PluginID,                                            \
            (const char*)PLUGIN_PROCESSOR_UID,                                \
            sizeof(effDesc.mVST3PluginID));                                   \
        return &effDesc;                                                      \
    }
#else
#define LIBPLUGIN_ADD_PLUGIN_AAX_WRAPPER()
#endif

#if defined(LIBPLUGIN_BUILD_AU2_WRAPPER)
#define LIBPLUGIN_ADD_PLUGIN_AU2_WRAPPER(processor_class_m, controller_class_m)
// TODO
#else
#define LIBPLUGIN_ADD_PLUGIN_AU2_WRAPPER(processor_class_m, controller_class_m)
#endif

#if defined(LIBPLUGIN_BUILD_AU3_WRAPPER)
#define LIBPLUGIN_ADD_PLUGIN_AU3_WRAPPER(processor_class_m, controller_class_m)
// TODO
#else
#define LIBPLUGIN_ADD_PLUGIN_AU3_WRAPPER(processor_class_m, controller_class_m)
#endif

#if defined(LIBPLUGIN_BUILD_VST2_WRAPPER)
#include <public.sdk/source/vst/vst2wrapper/vst2wrapper.h>
#define LIBPLUGIN_ADD_PLUGIN_VST2_WRAPPER()                                                                     \
    AudioEffect* createEffectInstance(audioMasterCallback audioMaster)                                          \
    {                                                                                                           \
        return Steinberg::Vst::Vst2Wrapper::create(GetPluginFactory(), PLUGIN_PROCESSOR_UID, 666, audioMaster); \
    }

#else
#define LIBPLUGIN_ADD_PLUGIN_VST2_WRAPPER()
#endif

namespace libplugin {
namespace detail {

    static const Steinberg::FUID processor_uid(0xAA2A0417, 0x063258BE, 0xB5FBD442, 0x8AC87FF6);
    static const Steinberg::FUID controller_uid(0x3C7F1B00, 0x60895F92, 0x98387CFE, 0x73381868);

    template <typename vst3_processor_t>
    constexpr bool is_processor_valid()
    {
		// https://marcofoco.com/blog/2016/10/03/the-power-of-devirtualization/
		
        // has processor createInstance
        // has processor initialize
        // has processor initialize
        return true;
    }

    template <typename vst3_controller_t>
    constexpr bool is_controller_valid()
    {

        return true;
    }

}
}